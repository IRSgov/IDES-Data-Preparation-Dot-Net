<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="IDES Data Preparation.NET : An example of the data preparation process using .NET Framework">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>IDES Data Preparation.NET</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/IRSgov/IDES-Data-Preparation-Dot-Net">View on GitHub</a>

          <h1 id="project_title">IDES Data Preparation.NET</h1>
          <h2 id="project_tagline">An example of the data preparation process using .NET Framework</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Dot-Net/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Dot-Net/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="ides-data-preparation" class="anchor" href="#ides-data-preparation" aria-hidden="true"><span class="octicon octicon-link"></span></a>IDES Data Preparation</h2>

<p>The International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and foreign tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). </p>

<p>The IDES Data Preparation.NET project repository demonstrates a working application built using <a href="http://www.visualstudio.com/en-us/products/free-developer-offers-vs">Microsoft Visual Studio 2013 Community edition</a>.  There are many tools available that may produce the same results. The IRS does not endorse any software applications or commercial products.</p>

<p>The example explains how to create a new project and use the code to build an application that will create a valid transmission and process notifications through IDES. The project starts with a validated FATCA XML file. The application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format that is ready for transmission in IDES.  </p>

<h3>
<a id="create-a-new-project" class="anchor" href="#create-a-new-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create a New Project</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img1.png" alt="Image 1"><br>
Figure 1   </p>

<p>Open <strong>Visual Studio</strong>, select <strong>New Project</strong>.   </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img2.png" alt="Image 2"><br>
Figure 2  </p>

<p>Under <strong>New Project</strong>, select the settings Visual C#, Windows Desktop and Windows Forms Application. Verify the settings, name and location. Click <strong>OK</strong> to continue.  </p>

<h3>
<a id="adding-references" class="anchor" href="#adding-references" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding References</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img3.png" alt="Image 3"><br>
Figure 3  </p>

<p>Next, you will add a reference to the each of the following:</p>

<ul>
<li>System.IO.Compression</li>
<li>System.IO.Compression.FileSystem</li>
<li>System.Security<br>
Select the <strong>Project ** and **Add Reference</strong> from the program menu. The <strong>Reference Manager-SignXML</strong> screen appears. Select the checkbox next to each entry and click <strong>OK</strong>.</li>
</ul>

<h3>
<a id="adding-components" class="anchor" href="#adding-components" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding Components</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img4.png" alt="Image 4">
Figure 4  </p>

<p>In the <strong>Designer Interface</strong>, add the components listed below. The selections are used when you run the application. The figure above shows a sample layout.</p>

<table>
<thead>
<tr>
<th align="center">Label</th>
<th align="center">Text</th>
<th align="center">Button</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">lblLoadXM</td>
<td align="center">txtXmlFile</td>
<td align="center">btnBrowseXml</td>
</tr>
<tr>
<td align="center">lblCert</td>
<td align="center">txtCert</td>
<td align="center">btnBrowseCert</td>
</tr>
<tr>
<td align="center">lblCertPass</td>
<td align="center"><strong>txtCertPass</strong></td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">lblKeyCert</td>
<td align="center">txtKeyCert</td>
<td align="center">btnBrowseKeyCert</td>
</tr>
<tr>
<td align="center">lblKeyEncryptionCertPassword</td>
<td align="center">txtKeyCertPassword</td>
<td align="center">btnSignXML</td>
</tr>
<tr>
<td align="center">lblZipFile</td>
<td align="center">txtNotificationZip</td>
<td align="center">btnBrowseNotificationZip</td>
</tr>
<tr>
<td align="center">lblReceiverCert</td>
<td align="center">txtReceiverCert</td>
<td align="center">btnBrowseRecCert</td>
</tr>
<tr>
<td align="center">lblRecPass</td>
<td align="center"><strong>txtRecKeyPassword</strong></td>
<td align="center">btnDecryptZip</td>
</tr>
<tr>
<td align="center">lblSender</td>
<td align="center">txtSenderCode</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">lblReceiver</td>
<td align="center">txtReceiverCode</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">lblOutput</td>
<td align="center">txtNotificationFolder</td>
<td align="center">btnBrowseOutput</td>
</tr>
<tr>
<td align="center">OpenFileDialog</td>
<td align="center">dlgOpen</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">SaveFileDialog</td>
<td align="center">dlgSave</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">FolderBrowserDialog</td>
<td align="center">dlgOpenFolder</td>
<td align="center">N/A</td>
</tr>
</tbody>
</table>

<p>Note: The <strong>passwordChar</strong> attribute can be set to mask the input for this text box.  </p>

<h2>
<a id="create-class-files" class="anchor" href="#create-class-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create Class Files</h2>

<h3>
<a id="organizing-class-files" class="anchor" href="#organizing-class-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>Organizing Class Files</h3>

<p>The descriptions of the interface components may be modified to provide more detail.  </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img5.png" alt="Image 5">
Figure 5  </p>

<p>In <strong>Solution Explorer</strong>, add a new folder named *<em>Helpers *</em> that will contain class files or modules for the phase of the application.  </p>

<h3>
<a id="class-file---extensionmethodscs" class="anchor" href="#class-file---extensionmethodscs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class File - ExtensionMethods.cs</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img6.png" alt="Image 6"><br>
Figure 6  </p>

<p>In the <strong>Helpers</strong> folder, create a new class file named <strong>ExtensionMethods.cs</strong>.  </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img7.png" alt="Image 7"><br>
Figure 7    </p>

<p>Next, letâ€™s create code used to display error messages and show the file load dialog screens. In the new class <strong>ExtensionMethods.cs</strong> , enter the following:  </p>

<div class="highlight highlight-c#"><pre><span class="pl-k">using</span> System;
<span class="pl-k">using</span> System.Windows.Forms;

<span class="pl-k">namespace</span> <span class="pl-en">WindowsFormsApplication1</span>
{
    <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">ExtensionMethods</span>
    {
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">string</span> <span class="pl-en">ShowDialogWithFilter</span>(<span class="pl-st">this</span> <span class="pl-vpf">OpenFileDialog</span> dialog, <span class="pl-st">string</span> <span class="pl-vpf">filter</span>)
        {
            dialog.Filter = filter;

            <span class="pl-k">if</span> (dialog.ShowDialog() == DialogResult.OK)
            {
                <span class="pl-k">return</span> dialog.FileName;
            }

            <span class="pl-k">return</span> <span class="pl-st">string</span>.Empty;
        }

        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">DisplayException</span>(<span class="pl-st">this</span> <span class="pl-vpf">Exception</span> ex, <span class="pl-st">string</span> <span class="pl-vpf">messageBoxTitle</span>)
        {
            <span class="pl-st">string</span> errorMessage = ex.GetBaseException().Message;

            <span class="pl-k">if</span> (errorMessage.Contains(<span class="pl-s1"><span class="pl-pds">"</span>password<span class="pl-pds">"</span></span>))
            {
                <span class="pl-c">// certificate password is incorrect</span>
                MessageBox.Show(<span class="pl-s1"><span class="pl-pds">"</span>Specified certificate password is incorrect!<span class="pl-pds">"</span></span>, 
messageBoxTitle, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                <span class="pl-k">return</span>;
            }

            <span class="pl-c">// other error</span>
            MessageBox.Show(errorMessage, messageBoxTitle, MessageBoxButtons.OK, MessageBoxIcon.Warning);
        }



    }
}
</pre></div>

<h3>
<a id="class-file---xmlsignercs" class="anchor" href="#class-file---xmlsignercs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class File - XmlSigner.cs</h3>

<p>Create a new class named <strong>XmlSigner.cs</strong> in the <strong>Helpers</strong> folder and add the following code to the new <strong>XmlSigner.cs</strong> class:  </p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Text;
using System.Xml;
using System.Linq;
using System.Collections.Generic;

namespace WindowsFormsApplication1
{
    /// &lt;summary&gt;
    /// The type of signature to perform
    /// &lt;/summary&gt;
    public enum XmlSignatureType
    {

        Enveloping
    }

    class XmlManager
    {
        #region Private methods
        /// &lt;summary&gt;
        /// Creates a KeyInfo object based on information from specified certificate
        /// &lt;/summary&gt;
        /// &lt;param name="certificate"&gt;The certificate used to create the KeyInfo from&lt;/param&gt;
        /// &lt;returns&gt;KeyInfo object&lt;/returns&gt;
        private static KeyInfo CreateKeyInfoFromCertificate(X509Certificate2 certificate)
        {
            // create KeyInfoX509Data object &amp; include certificate subject
            KeyInfoX509Data kiData = new KeyInfoX509Data(certificate);
            kiData.AddSubjectName(certificate.Subject);

            // create KeyInfo object with specified KeyInfoX509Data
            KeyInfo keyInfo = new KeyInfo();
            keyInfo.AddClause(kiData);

            return keyInfo;
        }

        /// &lt;summary&gt;
        /// Gets the RSA private key from the specified signing certificate
        /// &lt;/summary&gt;
        /// &lt;param name="certificate"&gt;The certificate used to extract the key from&lt;/param&gt;
        /// &lt;returns&gt;RSACryptoServiceProvider object&lt;/returns&gt;
        private static RSACryptoServiceProvider GetSigningRsaKeyFromCertificate(X509Certificate2 certificate)
        {
            RSACryptoServiceProvider key = new RSACryptoServiceProvider(new CspParameters(24));
            key.FromXmlString(certificate.PrivateKey.ToXmlString(true));

            return key;
        }

        /// &lt;summary&gt;
        /// Loads the specified certificate using specific storage flags for SHA-256
        /// &lt;/summary&gt;
        /// &lt;param name="certFile"&gt;The certificate file to open&lt;/param&gt;
        /// &lt;param name="certPassword"&gt;The certificate password&lt;/param&gt;
        /// &lt;param name="signWithSha256"&gt;Sign the document using SHA-256&lt;/param&gt;
        /// &lt;returns&gt;X509Certificate2 object&lt;/returns&gt;
        private static X509Certificate2 LoadSigningCertificate(string certFile, string certPassword, bool signWithSha256)
        {
            X509Certificate2 certificate = null;

            if (signWithSha256)
            {
                // register SHA-256 and open certificate with exportable private key
                CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription), RSAPKCS1SHA256SignatureDescription.SignatureMethod);
                certificate = new X509Certificate2(certFile, certPassword, X509KeyStorageFlags.Exportable);
            }
            else
            {
                // open certificate with password (to be able to access the private key)
                certificate = new X509Certificate2(certFile, certPassword);
            }

            return certificate;
        }

        /// &lt;summary&gt;
        /// Generates a SignedXml object
        /// &lt;/summary&gt;
        /// &lt;param name="doc"&gt;The XML data to sign represented as XmlDocument object&lt;/param&gt;
        /// &lt;param name="certificate"&gt;The certificate used for signing represented as X509Certificate2 object&lt;/param&gt;
        /// &lt;param name="signWithSha256"&gt;Sign the document using SHA-256&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private static SignedXml GenerateSignedXml(XmlDocument doc, X509Certificate2 certificate, bool signWithSha256)
        {
            // create new SignedXml from XmlDocument
            SignedXml signed = new SignedXml(doc);

            if (signWithSha256)
            {
                // set signing key and signature method for SHA-256
                signed.SigningKey = GetSigningRsaKeyFromCertificate(certificate);
                signed.SignedInfo.SignatureMethod = RSAPKCS1SHA256SignatureDescription.SignatureMethod;
            }
            else
            {
                // set signing key and signature method for SHA-1
                signed.SigningKey = certificate.PrivateKey;
            }

            return signed;
        }

        /// &lt;summary&gt;
        /// Signs a XML file (enveloped signature) using a digital certificate
        /// &lt;/summary&gt;
        /// &lt;param name="xml"&gt;The XML data to sign represented as byte array&lt;/param&gt;
        /// &lt;param name="certFile"&gt;The certificate file to use for signing&lt;/param&gt;
        /// &lt;param name="certPassword"&gt;The certificate password&lt;/param&gt;
        /// &lt;param name="signWithSha256"&gt;Sign the document using SHA-256&lt;/param&gt;
        /// &lt;returns&gt;The signed data represented as byte array&lt;/returns&gt;
        private static byte[] SignEnvelopedXml(byte[] xml, string certFile, string certPassword, bool signWithSha256)
        {
            if (xml == null || xml.Length == 0)
            {
                // invalid XML array
                throw new Exception("Nothing to sign!");
            }

            // load certificate
            X509Certificate2 certificate = LoadSigningCertificate(certFile, certPassword, signWithSha256);

            if (!certificate.HasPrivateKey)
            {
                // invalid certificate
                throw new Exception("Specified certificate not suitable for signing!");
            }

            using (MemoryStream stream = new MemoryStream(xml))
            {
                // go to the beginning of the stream
                stream.Flush();
                stream.Position = 0;

                // create new XmlDocument from stream
                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };
                doc.Load(stream);

                // create new SignedXml from XmlDocument
                SignedXml signed = GenerateSignedXml(doc, certificate, signWithSha256);

                // create reference &amp; add enveloped transform
                Reference reference = new Reference(string.Empty);
                reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());

                if (signWithSha256)
                {
                    // SHA-256 digest
                    reference.DigestMethod = RSAPKCS1SHA256SignatureDescription.ReferenceDigestMethod;
                }

                // add reference to document
                signed.AddReference(reference);

                // include KeyInfo object &amp; compute signature
                signed.KeyInfo = CreateKeyInfoFromCertificate(certificate);
                signed.ComputeSignature();

                // get signature &amp; append node
                XmlElement xmlDigitalSignature = signed.GetXml();
                doc.DocumentElement.AppendChild(doc.ImportNode(xmlDigitalSignature, true));

                // returned content as byte array
                return Encoding.UTF8.GetBytes(doc.OuterXml);
            }
        }

        /// &lt;summary&gt;
        /// Signs a XML file (enveloping signature) using a digital certificate
        /// &lt;/summary&gt;
        /// &lt;param name="xml"&gt;The XML data to sign represented as byte array&lt;/param&gt;
        /// &lt;param name="certFile"&gt;The certificate file to use for signing&lt;/param&gt;
        /// &lt;param name="certPassword"&gt;The certificate password&lt;/param&gt;
        /// &lt;param name="signWithSha256"&gt;Sign the document using SHA-256&lt;/param&gt;
        /// &lt;returns&gt;The signed data represented as byte array&lt;/returns&gt;
        private static byte[] SignEnvelopingXml(byte[] xml, string certFile, string certPassword, bool signWithSha256)
        {
            if (xml == null || xml.Length == 0)
            {
                // invalid XML array
                throw new Exception("Nothing to sign!");
            }

            // load certificate
            X509Certificate2 certificate = LoadSigningCertificate(certFile, certPassword, signWithSha256);

            if (!certificate.HasPrivateKey)
            {
                // invalid certificate
                throw new Exception("Specified certificate not suitable for signing!");
            }

            using (MemoryStream stream = new MemoryStream(xml))
            {
                // go to the beginning of the stream
                stream.Flush();
                stream.Position = 0;

                // create new XmlDocument from stream
                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };
                doc.Load(stream);

                // craete transform (for canonicalization method &amp; reference)
                XmlDsigExcC14NTransform transform = new XmlDsigExcC14NTransform();

                // create new SignedXml from XmlDocument
                SignedXml signed = GenerateSignedXml(doc, certificate, signWithSha256);
                signed.SignedInfo.CanonicalizationMethod = transform.Algorithm;

                // get nodes (use XPath to include FATCA declaration)
                XmlNodeList nodes = doc.DocumentElement.SelectNodes("/*");

                // define data object
                DataObject dataObject = new DataObject() { Data = nodes, Id = "FATCA" };

                // add the data we are signing as a sub-element (object) of the signature element
                signed.AddObject(dataObject);

                // create reference
                Reference reference = new Reference(string.Format("#{0}", dataObject.Id));
                reference.AddTransform(transform);

                if (signWithSha256)
                {
                    // SHA-256 digest
                    reference.DigestMethod = RSAPKCS1SHA256SignatureDescription.ReferenceDigestMethod;
                }

                // add reference to document
                signed.AddReference(reference);

                // include KeyInfo object &amp; compute signature
                signed.KeyInfo = CreateKeyInfoFromCertificate(certificate);
                signed.ComputeSignature();

                // get signature
                XmlElement xmlDigitalSignature = signed.GetXml();

                // XML declaration
                string xmlDeclaration = string.Empty;

                if (doc.FirstChild is XmlDeclaration)
                {
                    // include declaration
                    xmlDeclaration = doc.FirstChild.OuterXml;
                }

                // return signature as byte array
                return Encoding.UTF8.GetBytes(string.Concat(xmlDeclaration, xmlDigitalSignature.OuterXml));
            }
        }
        #endregion Private methods

        /// &lt;summary&gt;
        /// Signs a XML file using a digital certificate
        /// &lt;/summary&gt;
        /// &lt;param name="signatureType"&gt;The type of signature to perform&lt;/param&gt;
        /// &lt;param name="xml"&gt;The XML data to sign represented as byte array&lt;/param&gt;
        /// &lt;param name="certFile"&gt;The certificate file to use for signing&lt;/param&gt;
        /// &lt;param name="certPassword"&gt;The certificate password&lt;/param&gt;
        /// &lt;param name="signWithSha256"&gt;Sign the document using SHA-256&lt;/param&gt;
        /// &lt;returns&gt;The signed data represented as byte array&lt;/returns&gt;
        public static byte[] Sign(XmlSignatureType signatureType, byte[] xml, string certFile, string certPassword, bool signWithSha256 = true)
        {
            switch (signatureType)
            {

                case XmlSignatureType.Enveloping:
                    return SignEnvelopingXml(xml, certFile, certPassword, signWithSha256);

                default:
                    throw new Exception("Please use a valid XML signature type!");
            }
        }

        /// &lt;summary&gt;
        /// Verifies if the signature of the file is valid
        /// &lt;/summary&gt;
        /// &lt;param name="signedXml"&gt;The path to the signed file&lt;/param&gt;
        /// &lt;returns&gt;True or false&lt;/returns&gt;
        public static bool CheckSignature(string signedXml)
        {
            byte[] xml = File.ReadAllBytes(signedXml);

            using (MemoryStream stream = new MemoryStream(xml))
            {
                // go to the beginning of the stream
                stream.Flush();
                stream.Position = 0;

                // create new XmlDocument from stream
                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };
                doc.Load(stream);

                // get signature node
                XmlNodeList nodeList = doc.GetElementsByTagName("Signature");

                if (nodeList.Count != 1)
                {
                    // invalid file
                    throw new Exception("Signature is missing or multiple signatures found!");
                }

                // create SignedXml and load it with data
                SignedXml signed = new SignedXml(doc);
                signed.LoadXml(nodeList[0] as XmlElement);

                // check
                return signed.CheckSignature();
            }
        }
    }
}
</code></pre>

<h3>
<a id="class-file-rsapkcs1sha256signaturedescriptioncs" class="anchor" href="#class-file-rsapkcs1sha256signaturedescriptioncs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class File-RSAPKCS1SHA256SignatureDescription.cs</h3>

<p>Create a new class named <strong>RSAPKCS1SHA256SignatureDescription.cs</strong>in the <strong>Helpers</strong> folder and add the code to the new <strong>RSAPKCS1SHA256SignatureDescription.cs</strong> class:   </p>

<pre><code>using System;
using System.Security.Cryptography;

namespace WindowsFormsApplication1
{
    public sealed class RSAPKCS1SHA256SignatureDescription : SignatureDescription
    {
        public const string SignatureMethod = "http://" + "www.w3.org/2001/04/xmldsig-more#rsa-sha256";
        public const string ReferenceDigestMethod = "http://" + "www.w3.org/2001/04/xmlenc#sha256";

        public RSAPKCS1SHA256SignatureDescription()
        {
            KeyAlgorithm = typeof(RSACryptoServiceProvider).FullName;
            DigestAlgorithm = typeof(SHA256Managed).FullName;
            FormatterAlgorithm = typeof(RSAPKCS1SignatureFormatter).FullName;
            DeformatterAlgorithm = typeof(RSAPKCS1SignatureDeformatter).FullName;
        }

        public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
        {
            if (key == null)
            {
                throw new Exception("Invalid key specified for RSAPKCS1SHA256SignatureDescription!");
            }

            RSAPKCS1SignatureDeformatter deformatter = new RSAPKCS1SignatureDeformatter(key);
            deformatter.SetHashAlgorithm("SHA256");

            return deformatter;
        }

        public override AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
        {
            if (key == null)
            {
                throw new Exception("Invalid key specified for RSAPKCS1SHA256SignatureDescription!");
            }

            RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter(key);
            formatter.SetHashAlgorithm("SHA256");

            return formatter;
        }
    }
}

</code></pre>

<h3>
<a id="class-file-zipmanagercs" class="anchor" href="#class-file-zipmanagercs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class File-ZipManager.cs</h3>

<p>Create a new class named <strong>ZipManager.cs</strong> in the Helpers folder and add the following code to the new <strong>ZipManager.cs</strong> class:</p>

<pre><code>using System.IO;
using System.IO.Compression;

namespace WindowsFormsApplication1
{
    class ZipManager
    {
        public static void CreateArchive(string inputFileName, string outputFileName)
        {
            using (FileStream fs = new FileStream(outputFileName, FileMode.Create, FileAccess.Write))
            {
                using (ZipArchive archive = new ZipArchive(fs, ZipArchiveMode.Create))
                {
                    string entryName = Path.GetFileName(inputFileName);
                    archive.CreateEntryFromFile(inputFileName, entryName, CompressionLevel.Optimal);
                }
            }
        }

        public static void UpdateArchive(string inputFileName, string outputFileName)
        {
            using (FileStream fs = new FileStream(outputFileName, FileMode.Open, FileAccess.ReadWrite))
            {
                using (ZipArchive archive = new ZipArchive(fs, ZipArchiveMode.Update))
                {
                    string entryName = Path.GetFileName(inputFileName);
                    archive.CreateEntryFromFile(inputFileName, entryName, CompressionLevel.Optimal);
                }
            }
        }

        public static string ExtractArchive(string inputFileName, string outputFolder)
        {
            string zipFileName = Path.GetFileNameWithoutExtension(inputFileName);
            string zipFolderPath = outputFolder + "\\" + zipFileName;

            using (ZipArchive archive = ZipFile.Open(inputFileName, ZipArchiveMode.Update))
            {

                archive.ExtractToDirectory(zipFolderPath);
            }

            return zipFolderPath;

        }

        public static void ExtractArchive(string inputFileName, string outputFolder, bool noPath)
        {

            string zipFileName = Path.GetFileName(inputFileName);
            string zipFolderPath = inputFileName.Replace(zipFileName, "");

            using (ZipArchive archive = ZipFile.Open(inputFileName, ZipArchiveMode.Update))
            {

                archive.ExtractToDirectory(zipFolderPath);
            }



        }
    }




}
</code></pre>

<h3>
<a id="class-file-aesmanagercs" class="anchor" href="#class-file-aesmanagercs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class File-AesManager.cs</h3>

<p>Create a new class in the <strong>Helpers</strong> folder named <strong>AesManager.cs</strong> and add the following code to the new <strong>AesManager.cs</strong> class:  </p>

<div class="highlight highlight-c#"><pre><span class="pl-k">using</span> System;
<span class="pl-k">using</span> System.IO;
<span class="pl-k">using</span> System.Security.Cryptography;
<span class="pl-k">using</span> System.Security.Cryptography.X509Certificates;

<span class="pl-k">namespace</span> <span class="pl-en">WindowsFormsApplication1</span>
{
    <span class="pl-s">class</span> <span class="pl-en">AesManager</span>
    {
        <span class="pl-s">private</span> <span class="pl-s">const</span> <span class="pl-st">int</span> bufferSize = <span class="pl-c1">1024</span> * <span class="pl-c1">8</span>;
        <span class="pl-s">private</span> <span class="pl-s">const</span> <span class="pl-st">int</span> keySize = <span class="pl-c1">256</span>;

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// AES key size</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">int</span> KeySize
        {
            <span class="pl-k">get</span>
            {
                <span class="pl-k">return</span> keySize;
            }
        }

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// Generates a random key of the specified size</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>length<span class="pl-pds">"</span></span>&gt;The length of the key to generate&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>emptyBytes<span class="pl-pds">"</span></span>&gt;If true all bytes will contain zeroes&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">returns</span>&gt;A random key represented as byte array&lt;/<span class="pl-ent">returns</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">byte</span>[] <span class="pl-en">GenerateRandomKey</span>(<span class="pl-st">int</span> <span class="pl-vpf">length</span>, <span class="pl-st">bool</span> <span class="pl-vpf">emptyBytes</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>)
        {
            <span class="pl-st">byte</span>[] key = <span class="pl-s">new</span> <span class="pl-st">byte</span>[length];

            <span class="pl-k">if</span> (emptyBytes)
            {
                <span class="pl-k">return</span> key;
            }

            <span class="pl-k">using</span> (RNGCryptoServiceProvider random = <span class="pl-s">new</span> RNGCryptoServiceProvider())
            {
                random.GetBytes(key);
            }

            <span class="pl-k">return</span> key;
        }

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// Encrypts a file with AES</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>filePath<span class="pl-pds">"</span></span>&gt;Full path of the file to be encrypted&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>outputFilePath<span class="pl-pds">"</span></span>&gt;Full path of the encrypted file&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>&gt;AES encryption key&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>iv<span class="pl-pds">"</span></span>&gt;AES initialization vector&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">EncryptFile</span>(<span class="pl-st">string</span> <span class="pl-vpf">filePath</span>, <span class="pl-st">string</span> <span class="pl-vpf">outputFilePath</span>, <span class="pl-st">byte[]</span> <span class="pl-vpf">key</span>, <span class="pl-st">byte[]</span> <span class="pl-vpf">iv</span>)
        {
            <span class="pl-k">using</span> (AesCryptoServiceProvider aes = <span class="pl-s">new</span> AesCryptoServiceProvider())
            {
                aes.Mode = CipherMode.ECB;
                aes.Key = key;
                aes.IV = iv;


                <span class="pl-k">using</span> (ICryptoTransform cryptoTransform = aes.CreateEncryptor(aes.Key, aes.IV))
                {
                    <span class="pl-k">using</span> (FileStream plain = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        <span class="pl-k">using</span> (FileStream encrypted = File.Open(outputFilePath, FileMode.Create, FileAccess.Write, FileShare.None))
                        {
                            <span class="pl-k">using</span> (CryptoStream cs = <span class="pl-s">new</span> CryptoStream(encrypted, cryptoTransform, CryptoStreamMode.Write))
                            {
                                plain.CopyTo(cs, bufferSize);
                            }
                        }
                    }
                }
            }
        }

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// Decrypts a file encrypted with AES</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>filePath<span class="pl-pds">"</span></span>&gt;Full path of the file to be decrypted&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>outputFilePath<span class="pl-pds">"</span></span>&gt;Full path of the decrypted file&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>&gt;AES decryption key&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>iv<span class="pl-pds">"</span></span>&gt;AES initialization vector&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">DecryptFile</span>(<span class="pl-st">string</span> <span class="pl-vpf">filePath</span>, <span class="pl-st">string</span> <span class="pl-vpf">outputFilePath</span>, <span class="pl-st">byte[]</span> <span class="pl-vpf">key</span>, <span class="pl-st">byte[]</span> <span class="pl-vpf">iv</span>)
        {
            <span class="pl-k">using</span> (AesCryptoServiceProvider aes = <span class="pl-s">new</span> AesCryptoServiceProvider())
            {
                aes.Mode = CipherMode.ECB;
                aes.Key = key;
                aes.IV = iv;

                <span class="pl-k">using</span> (ICryptoTransform cryptoTransform = aes.CreateDecryptor(aes.Key, aes.IV))
                {
                    <span class="pl-k">using</span> (FileStream encrypted = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        <span class="pl-k">using</span> (FileStream plain = File.Open(outputFilePath, FileMode.Create, FileAccess.Write, FileShare.None))
                        {
                            <span class="pl-k">using</span> (CryptoStream cs = <span class="pl-s">new</span> CryptoStream(plain, cryptoTransform, CryptoStreamMode.Write))
                            {
                                encrypted.CopyTo(cs, bufferSize);
                            }
                        }
                    }
                }
            }
        }

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// Encrypts a key using the public key from the specified certificate</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>payload<span class="pl-pds">"</span></span>&gt;The data to encrypt&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>encryptionCert<span class="pl-pds">"</span></span>&gt;The certificate used for encryption&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>encryptionCertPassword<span class="pl-pds">"</span></span>&gt;The password for the encryption certificate&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>outputFilePath<span class="pl-pds">"</span></span>&gt;Full path of the encrypted file&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">EncryptAesKey</span>(<span class="pl-st">byte[]</span> <span class="pl-vpf">payload</span>, <span class="pl-st">string</span> <span class="pl-vpf">encryptionCert</span>, <span class="pl-st">string</span> <span class="pl-vpf">encryptionCertPassword</span>, <span class="pl-st">string</span> <span class="pl-vpf">outputFilePath</span>)
        {
            X509Certificate2 cert = <span class="pl-s">new</span> X509Certificate2(encryptionCert, encryptionCertPassword);

            <span class="pl-k">using</span> (RSACryptoServiceProvider rsa = cert.PublicKey.Key <span class="pl-k">as</span> RSACryptoServiceProvider)
            {
                <span class="pl-st">byte</span>[] encryptedKey = rsa.Encrypt(payload, <span class="pl-c1">false</span>);
                File.WriteAllBytes(outputFilePath, encryptedKey);
            }
        }

        <span class="pl-c">/// &lt;<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// Decrypts a key using the private key from the specified certificate</span>
        <span class="pl-c">/// &lt;/<span class="pl-ent">summary</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>payload<span class="pl-pds">"</span></span>&gt;The data to decrypt&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>encryptionCert<span class="pl-pds">"</span></span>&gt;The certificate used for decryption&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">param</span> <span class="pl-e">name</span>=<span class="pl-s1"><span class="pl-pds">"</span>encryptionCertPassword<span class="pl-pds">"</span></span>&gt;The password for the decryption certificate&lt;/<span class="pl-ent">param</span>&gt;</span>
        <span class="pl-c">/// &lt;<span class="pl-ent">returns</span>&gt;Decrypted key represented as byte array&lt;/<span class="pl-ent">returns</span>&gt;</span>
        <span class="pl-s">public</span> <span class="pl-s">static</span> <span class="pl-st">byte</span>[] <span class="pl-en">DecryptAesKey</span>(<span class="pl-st">byte[]</span> <span class="pl-vpf">payload</span>, <span class="pl-st">string</span> <span class="pl-vpf">encryptionCert</span>, <span class="pl-st">string</span> <span class="pl-vpf">encryptionCertPassword</span>)
        {
            X509Certificate2 cert = <span class="pl-s">new</span> X509Certificate2(encryptionCert, encryptionCertPassword);

            <span class="pl-k">if</span> (!cert.HasPrivateKey)
            {
                <span class="pl-c">// invalid certificate</span>
                <span class="pl-k">throw</span> <span class="pl-s">new</span> Exception(<span class="pl-s1"><span class="pl-pds">"</span>Specified certificate not suitable for decryption!<span class="pl-pds">"</span></span>);

            }

            <span class="pl-k">using</span> (RSACryptoServiceProvider rsa = cert.PrivateKey <span class="pl-k">as</span> RSACryptoServiceProvider)
            {

                <span class="pl-k">return</span> rsa.Decrypt(payload, <span class="pl-c1">false</span>);
            }
        }
    }
}
</pre></div>

<p><strong>Note: There should be five (5) classes in the Helpers folder.</strong>  </p>

<h3>
<a id="adding-a-using-statement" class="anchor" href="#adding-a-using-statement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding a using Statement</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img8.png" alt="Image 8">
Figure 8</p>

<p>In <strong>Form1.cs</strong>, enter the following using statements:</p>

<pre><code>using System;
using System.IO;
using System.Windows.Forms;
using System.Xml;
using System.Text;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;  
</code></pre>

<h3>
<a id="enter-methods-for-click-events" class="anchor" href="#enter-methods-for-click-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enter Methods for Click Events</h3>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img9.png" alt="Image 9">
Figure 9  </p>

<p>In <strong>Form1.cs</strong>, enter methods that will handle the button click events for the form.</p>

<h4>
<a id="btnbrowsexml" class="anchor" href="#btnbrowsexml" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseXml</h4>

<p>Double click <strong>8btnBrowseXml</strong> on the designer and add the code:  </p>

<pre><code>private void btnBrowseXml_Click(object sender, EventArgs e)
    {
     // load XML
     txtXmlFile.Text = dlgOpen.ShowDialogWithFilter("XML Files
 (*.xml)|*.xml");
    }
</code></pre>

<h4>
<a id="btnbrowsecert" class="anchor" href="#btnbrowsecert" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseCert</h4>

<p>Double click <strong>btnBrowseCert</strong> on the designer and add the code:  </p>

<div class="highlight highlight-c#"><pre><span class="pl-s">private</span> <span class="pl-st">void</span> btnBrowseCert_Click(<span class="pl-st">object</span> sender, EventArgs e)
    {
      <span class="pl-c">// load certificate</span>
      txtCert.Text = dlgOpen.ShowDialogWithFilter(<span class="pl-s1"><span class="pl-pds">"</span>Signing Certificates</span>
<span class="pl-s1"> (*.pfx, *.p12)|*.pfx;*.p12<span class="pl-pds">"</span></span>);
     }</pre></div>

<h4>
<a id="btnbrowsekeycert" class="anchor" href="#btnbrowsekeycert" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseKeyCert</h4>

<p>Double click <strong>btnBrowseKeyCert</strong> on the designer and add the code:  </p>

<pre><code>private void btnBrowseKeyCert_Click(object sender, EventArgs e)
        {
            // load AES key encryption certificate
            txtKeyCert.Text = dlgOpen.ShowDialogWithFilter("Certificate Files
 (*.cer, *.pfx, *.p12)|*.cer;*.pfx;*.p12");
        }  
</code></pre>

<h4>
<a id="btnsignxml" class="anchor" href="#btnsignxml" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnSignXML</h4>

<p>Double click <strong>btnSignXML</strong> on the designer and add the code:  </p>

<pre><code>private void btnSignXML_Click(object sender, EventArgs e)
        {
            if (string.IsNullOrWhiteSpace(txtXmlFile.Text))
            {
                // files validation
                MessageBox.Show("The XML file was not specified!", Text, 
MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtCert.Text))
            {
                // files validation
                MessageBox.Show("The Signing Certificate was not specified!", 
Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtCertPass.Text))
            {
                // certificate password validation
                MessageBox.Show("Signing Certificate password was not specified!", 
Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (string.IsNullOrWhiteSpace(txtKeyCert.Text))
            {
                // files validation
                MessageBox.Show("Encryption Certificate was not specified!", 
Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            try
            {
                // load XML file content
                byte[] xmlContent = File.ReadAllBytes(txtXmlFile.Text);
                string senderGIIN = Path.GetFileNameWithoutExtension(txtXmlFile.Text);
                string filePath = Path.GetDirectoryName(txtXmlFile.Text);

                // perform sign
                byte[] envelopingSignature = XmlManager.Sign(XmlSignatureType.Enveloping, xmlContent, txtCert.Text, txtCertPass.Text);

                string envelopingFileName = txtXmlFile.Text.Replace(".xml", "_Payload.xml");
                string zipFileName = envelopingFileName.Replace(".xml", ".zip");

                // save enveloping version to disk
                File.WriteAllBytes(envelopingFileName, envelopingSignature);

                // add enveloping signature to ZIP file
                ZipManager.CreateArchive(envelopingFileName, zipFileName);

                // generate AES key (32 bytes) &amp; default initialization vector (empty)
                byte[] aesEncryptionKey = AesManager.GenerateRandomKey(AesManager.KeySize / 8);
                byte[] aesEncryptionVector = AesManager.GenerateRandomKey(16, true);

                // encrypt file &amp; save to disk
                string encryptedFileName = zipFileName.Replace(".zip", "");
                string payloadFileName = encryptedFileName;
                AesManager.EncryptFile(zipFileName, encryptedFileName, aesEncryptionKey, aesEncryptionVector);

                // encrypt key with public key of certificate &amp; save to disk
                // System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();
                //aesEncryptionKey = encoding.GetBytes("test");

                //  Byte[] bytes = System.Text.Encoder.GetBytes("some test data");
                encryptedFileName = Path.GetDirectoryName(zipFileName) + "\\000000.00000.TA.840_Key"; ;
                AesManager.EncryptAesKey(aesEncryptionKey, txtKeyCert.Text, txtKeyCertPassword.Text, encryptedFileName);

                // cleanup
                envelopingSignature = null;
                aesEncryptionKey = aesEncryptionVector = null;

                //Start creating XML metadata
                XmlWriter writer = null;
                string fileCreationDateTime = "";
                fileCreationDateTime = DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ");

                DateTime uDat = new DateTime();
                uDat = DateTime.UtcNow;
                string senderFile = uDat.ToString("yyyyMMddTHHmmssfffZ") + "_" + senderGIIN;

                try
                {

                    // Create an XmlWriterSettings object with the correct options. 
                    XmlWriterSettings settings = new XmlWriterSettings();
                    settings.Indent = true;
                    settings.IndentChars = ("\t");
                    settings.OmitXmlDeclaration = false;
                    settings.NewLineHandling = NewLineHandling.Replace;
                    settings.CloseOutput = true;

                    string metadataFileName = filePath + "\\" + senderGIIN + "_Metadata.xml";

                    // Create the XmlWriter object and write some content.
                    writer = XmlWriter.Create(metadataFileName, settings);
                    writer.WriteStartElement("FATCAIDESSenderFileMetadata", "urn:fatca:idessenderfilemetadata");
                    writer.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
                    writer.WriteStartElement("FATCAEntitySenderId");
                    writer.WriteString(senderGIIN);
                    writer.WriteEndElement();
                    writer.WriteStartElement("FATCAEntityReceiverId");
                    writer.WriteString("000000.00000.TA.840");
                    writer.WriteEndElement();
                    writer.WriteStartElement("FATCAEntCommunicationTypeCd");
                    writer.WriteString("RPT");
                    writer.WriteEndElement();
                    writer.WriteStartElement("SenderFileId");
                    writer.WriteString(senderFile);
                    writer.WriteEndElement();
                    writer.WriteStartElement("FileCreateTs");
                    writer.WriteString(fileCreationDateTime);
                    writer.WriteEndElement();
                    writer.WriteStartElement("TaxYear");
                    writer.WriteString("2014");
                    writer.WriteEndElement();
                    writer.WriteStartElement("FileRevisionInd");
                    writer.WriteString("false");
                    writer.WriteEndElement();
                    //Close the XmlTextWriter.
                    writer.WriteEndDocument();
                    writer.Close();
                    writer.Flush();


                    //Add the metadata, payload, and key files to the final zip package
                    // add enveloping signature to ZIP file
                    ZipManager.CreateArchive(metadataFileName, filePath + "\\" + senderFile + ".zip");
                    ZipManager.UpdateArchive(encryptedFileName, filePath + "\\" + senderFile + ".zip");
                    ZipManager.UpdateArchive(payloadFileName, filePath + "\\" + senderFile + ".zip");

                    // success
                    MessageBox.Show("XML Signing and Encryption process is complete!", Text, MessageBoxButtons.OK, MessageBoxIcon.Information);


                }
                finally
                {
                    if (writer != null)
                        writer.Close();
                }



            }
            catch (Exception ex)
            {
                ex.DisplayException(Text);
            }
        }  
</code></pre>

<h3>
<a id="btnbrowsenotificationzip" class="anchor" href="#btnbrowsenotificationzip" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseNotificationZip</h3>

<p>Double click <strong>btnBrowseNotificationZip</strong> on the designer and add this code:  </p>

<pre><code>private void btnBrowseNotificationZip_Click(object sender, EventArgs e)
        {
            // load Notification Zip file
            txtNotificationZip.Text = dlgOpen.ShowDialogWithFilter("ZIP Files (*.zip)|*.zip");
</code></pre>

<h3>
<a id="btnbrowsereccert" class="anchor" href="#btnbrowsereccert" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseRecCert</h3>

<p>Double click the <strong>btnBrowseRecCert</strong> on the designer and add this code:  </p>

<pre><code>private void btnBrowseRecCert_Click(object sender, EventArgs e)
        {
            // load Notification Receiver key
            txtReceiverCert.Text = dlgOpen.ShowDialogWithFilter("Certificate Files (*.cer, *.pfx, *.p12)|*.cer;*.pfx;*.p12");
        }  
</code></pre>

<h3>
<a id="btndecryptzip" class="anchor" href="#btndecryptzip" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnDecryptZip</h3>

<p>Double click the <strong>btnDecryptZip</strong> on the designer and add this code:  </p>

<pre><code>private void btnDecryptZip_Click(object sender, EventArgs e)
        {

            if (string.IsNullOrWhiteSpace(txtNotificationZip.Text) || string.IsNullOrWhiteSpace(txtReceiverCert.Text))
            {
                // files validation
                MessageBox.Show("Either the ZIP file or certificate was not specified!", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string zipFolder = "";
            try
            {
                //Deflate the zip archive
                zipFolder = ZipManager.ExtractArchive(txtNotificationZip.Text, txtNotificationFolder.Text);

            }
            catch (Exception ex)
            {
                ex.DisplayException(Text);
                return;
            }
            // select encrypted key file
            string encryptedKeyFile = "";
            string encryptedPayloadFile = "";
            string[] keyFiles = Directory.GetFiles(zipFolder, "*_Key", SearchOption.TopDirectoryOnly);
            string[] payloadFiles = Directory.GetFiles(zipFolder, "*_Payload", SearchOption.TopDirectoryOnly);

            if (keyFiles.Length == 0)
            {
                // key file validation
                MessageBox.Show("There was no file found containing the encrypted AES key!", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }
            if (payloadFiles.Length == 0)
            {
                // key file validation
                MessageBox.Show("There was no file found containing the encrypted Payload!", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }
            encryptedKeyFile = keyFiles[0];
            encryptedPayloadFile = payloadFiles[0];



            byte[] encryptedAesKey = null;
            byte[] decryptedAesKey = null;
            byte[] aesVector = null;

            try
            {
                // load encrypted AES key
                encryptedAesKey = File.ReadAllBytes(encryptedKeyFile);

                // decrypt AES key &amp; generate default (empty) initialization vector
                decryptedAesKey = AesManager.DecryptAesKey(encryptedAesKey, txtReceiverCert.Text, txtRecKeyPassword.Text);
                aesVector = AesManager.GenerateRandomKey(16, true);

                // decrypt encrypted ZIP file using decrypted AES key
                string decryptedFileName = encryptedPayloadFile.Replace("_Payload", "_Payload_decrypted.zip");
                AesManager.DecryptFile(encryptedPayloadFile, decryptedFileName, decryptedAesKey, aesVector);


                //Deflate the decrypted zip archive
                ZipManager.ExtractArchive(decryptedFileName, decryptedFileName, false);



                // success
                MessageBox.Show("Notification decryption process is complete!", Text, MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                ex.DisplayException(Text);
            }
            finally
            {
                if (encryptedAesKey != null)
                {
                    encryptedAesKey = null;
                }

                if (decryptedAesKey != null)
                {
                    decryptedAesKey = null;
                }

                if (aesVector != null)
                {
                    aesVector = null;
                }
            }
        }  
</code></pre>

<h3>
<a id="btnbrowseoutput" class="anchor" href="#btnbrowseoutput" aria-hidden="true"><span class="octicon octicon-link"></span></a>btnBrowseOutput</h3>

<p>Double click the <strong>btnBrowseOutput</strong> on the designer and add this code:  </p>

<pre><code>private void btnBrowseOutput_Click(object sender, EventArgs e)
    {
        // load AES key encryption certificate
        if (dlgOpenFolder.ShowDialog() == DialogResult.OK)
        {
            txtNotificationFolder.Text = dlgOpenFolder.SelectedPath;
        }
    }  
</code></pre>

<p>This is the end of the code used to create and run the application.  </p>

<h2>
<a id="create-a-transmission-file" class="anchor" href="#create-a-transmission-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create a Transmission File</h2>

<p>To create a transmission file for IDES, you are required to have (1) an .xml file, (2) a private key that will be used to sign the xml, and (3) the public key of the receiver. The file names are case sensitive and any variation in name, extension or format will cause a transmission failure.  There are no file extensions, unless otherwise noted. For more information, review the IDES User Guide.  </p>

<ol>
<li> Select the .xml file. The file should be correctly named  to create the correct sender metadata file. For example, Canada (ISO Code = 124) requires a file to be named 000000.00000.TA.124.xml.</li>
<li> Select the senderâ€™s private key. The application uses a <strong>.p12</strong> file that contains the private key. The key may be in a different format, such as a .pfx file.</li>
<li> If there is a password on the key file above, enter it here. </li>
<li> Select the receiverâ€™s public key. The application uses a <strong>.p12</strong> file that contains the public key. This may be in a different format, such as a .cer extension.</li>
<li> If there is a password on the public key, enter it here.</li>
<li> Enter the Sender Code and Receiver code. These will be used to ensure the files are correctly named. The sender is 124 (Canada) and the receiver is 840 (US/IRS) in this sample.<br>
</li>
</ol>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img10.png" alt="Image 10">
Figure 10  </p>

<ol>
<li> Click the <strong>Sign and Encrypt XML</strong> button. If the files and keys are set up correctly, a success message dialog box will appear. Click <strong>OK</strong> to continue.<br>
</li>
</ol>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img11.png" alt="Image 11"><br>
Figure 11    </p>

<h3>
<a id="creating-a-zip-file" class="anchor" href="#creating-a-zip-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating a .ZIP File</h3>

<p>The <strong>Sign and Encrypt XML</strong> button creates a .zip file that contains the key, payload, and sender metadata xml file. The zip filename should follow proper naming conventions and any variation in name, extension or format will cause a transmission failure. For example, the filename is 20150115T174443889Z_000000.00000.TA.124.zip. The contents of the sample .zip file are shown in Figure 12 below.  </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img12.png" alt="Image 12"><br>
Figure 12  </p>

<p>Next, you are ready to upload the transmission into IDES. For more information on using IDES, review the <a href="http://www.irs.gov/Businesses/Corporations/International-Data-Exchange-Service">IDES User Guide</a>.    </p>

<h2>
<a id="decrypting-a-notification" class="anchor" href="#decrypting-a-notification" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decrypting a Notification</h2>

<p>The application can be used to decrypt system notifications received in IDES. To decrypt the notification, the receiver must use their private key.  </p>

<ol>
<li> In IDES, download or save the notification to your hard drive.  Select the downloaded .zip notification file.</li>
<li> Select the private key of the receiver. The sample uses a .p12 format; however, the file can be modified for other formats.</li>
<li> If there is a password on the private key, enter it here.</li>
<li> The notification output folder controls the location of the decrypted output.<br>
</li>
<li> Click the <strong>Decrypt Notification</strong> button.<br>
</li>
</ol>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img13.png" alt="Image 13"><br>
Figure 13  </p>

<ol>
<li> If the correct key and password (optional) are used on the file, a success message dialog box will appear.<br>
</li>
<li> In the <strong>Notification Output Folder</strong> field, the location of the decrypted and signed xml file that contains the contents of the notification are present. For example, the file name 000000.00000.TA.840_Payload.xml is used in this sample.<br>
</li>
</ol>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img14.png" alt="Image 14">
Figure 14  </p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out the documentation at <a href="https://help.github.com/pages">https://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and weâ€™ll help you sort it out.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">IDES Data Preparation.NET maintained by <a href="https://github.com/IRSgov">IRSgov</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
