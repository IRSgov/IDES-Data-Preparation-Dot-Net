{"name":"IDES Data Preparation.NET","tagline":"An example of the data preparation process using .NET Framework","body":"## IDES Data Preparation\r\nThe International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and foreign tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). \r\n\r\nThe IDES Data Preparation.NET project repository demonstrates a working application built using [Microsoft Visual Studio 2013 Community edition](http://www.visualstudio.com/en-us/products/free-developer-offers-vs).  There are many tools available that may produce the same results. The IRS does not endorse any software applications or commercial products.\r\n\r\nThe example explains how to create a new project and use the code to build an application that will create a valid transmission and process notifications through IDES. The project starts with a validated FATCA XML file. The application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format that is ready for transmission in IDES.\r\n\r\nOpen **Visual Studio**, select **New Project**.\r\n![Image 1](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img1.png)\r\n\r\n### Create a New Project \r\n![Image 2](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img2.png)\r\nUnder **New Project**, select the settings Visual C#, Windows Desktop and Windows Forms Application. Verify the settings, name and location. Click **OK** to continue.\r\n\r\n### Adding References\r\n![Image 3](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img3.png)\r\nNext, you will add a reference to the each of the following:\r\n* System.IO.Compression\r\n* System.IO.Compression.FileSystem\r\n* System.Security  \r\nSelect the **Project ** and **Add Reference** from the program menu. The **Reference Manager-SignXML** screen appears. Select the checkbox next to each entry and click **OK**.\r\n\r\n\r\n### Adding Components\r\n![Image 3](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img4.png)\r\nIn the **Designer Interface**, add the components listed below. The selections are used when you run the application. The figure above shows a sample layout.\r\n\r\n\r\n| Label               | Text          | Button          |\r\n|:-------------------:|:-------------:|:---------------:|\r\n|lblLoadXM            |txtXmlFile     |btnBrowseXml     |\r\n|lblCert              |txtCert        |btnBrowseCert    |\r\n|lblCertPass          |**txtCertPass**    |N/A|\r\n|lblKeyCert           |txtKeyCert     |btnBrowseKeyCert  |\r\n|lblKeyEncryptionCertPassword |txtKeyCertPassword|btnSignXML|\r\n|lblZipFile |txtNotificationZip |btnBrowseNotificationZip|\r\n|lblReceiverCert |txtReceiverCert|btnBrowseRecCert |\r\n|lblRecPass |**txtRecKeyPassword** |btnDecryptZip|\r\n|lblSender  |txtSenderCode  |N/A|\r\n|lblReceiver  |txtReceiverCode  |N/A   |\r\n|lblOutput  |txtNotificationFolder  |btnBrowseOutput   |\r\n|OpenFileDialog  |dlgOpen  |N/A   |\r\n|SaveFileDialog  |dlgSave  |N/A   |\r\n|FolderBrowserDialog  |dlgOpenFolder  | N/A  |\r\n \r\nNote: The **passwordChar **attribute can be set to mask the input for this text box.\r\n\r\n## Create Class Files\r\n\r\n### Organizing Class Files \r\nThe descriptions of the interface components may be modified to provide more detail.\r\n  \r\n![Image 5](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img5.png)\r\nFigure 5  \r\n  \r\nIn **Solution Explorer**, add a new folder named **Helpers ** that will contain class files or modules for the phase of the application.  \r\n\r\n### Class File - ExtensionMethods.cs\r\n![Image 6](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img6.png)  \r\nFigure 6  \r\n\r\nIn the **Helpers** folder, create a new class file named **ExtensionMethods.cs**.  \r\n\r\n![Image 7](http://irsgov.github.io/IDES-Data-Preparation-Dot-Net/images/img7.png)  \r\nFigure 7    \r\n\r\nNext, let’s create code used to display error messages and show the file load dialog screens. In the new class **ExtensionMethods.cs** , enter the following:  \r\n \r\n```c#\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace WindowsFormsApplication1\r\n{\r\n    public static class ExtensionMethods\r\n    {\r\n        public static string ShowDialogWithFilter(this OpenFileDialog dialog, string filter)\r\n        {\r\n            dialog.Filter = filter;\r\n\r\n            if (dialog.ShowDialog() == DialogResult.OK)\r\n            {\r\n                return dialog.FileName;\r\n            }\r\n\r\n            return string.Empty;\r\n        }\r\n\r\n        public static void DisplayException(this Exception ex, string messageBoxTitle)\r\n        {\r\n            string errorMessage = ex.GetBaseException().Message;\r\n\r\n            if (errorMessage.Contains(\"password\"))\r\n            {\r\n                // certificate password is incorrect\r\n                MessageBox.Show(\"Specified certificate password is incorrect!\", \r\nmessageBoxTitle, MessageBoxButtons.OK, MessageBoxIcon.Warning);\r\n                return;\r\n            }\r\n\r\n            // other error\r\n            MessageBox.Show(errorMessage, messageBoxTitle, MessageBoxButtons.OK, MessageBoxIcon.Warning);\r\n        }\r\n\r\n\r\n\r\n    }\r\n}\r\n \r\n```\r\n\r\n### Class File - XmlSigner.cs\r\n\r\nCreate a new class named **XmlSigner.cs** in the **Helpers** folder and add the following code to the new **XmlSigner.cs** class:  \r\n\r\n```\r\nusing System;\r\nusing System.IO;\r\nusing System.Security.Cryptography;\r\nusing System.Security.Cryptography.X509Certificates;\r\nusing System.Security.Cryptography.Xml;\r\nusing System.Text;\r\nusing System.Xml;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\nnamespace WindowsFormsApplication1\r\n{\r\n    /// <summary>\r\n    /// The type of signature to perform\r\n    /// </summary>\r\n    public enum XmlSignatureType\r\n    {\r\n\r\n        Enveloping\r\n    }\r\n\r\n    class XmlManager\r\n    {\r\n        #region Private methods\r\n        /// <summary>\r\n        /// Creates a KeyInfo object based on information from specified certificate\r\n        /// </summary>\r\n        /// <param name=\"certificate\">The certificate used to create the KeyInfo from</param>\r\n        /// <returns>KeyInfo object</returns>\r\n        private static KeyInfo CreateKeyInfoFromCertificate(X509Certificate2 certificate)\r\n        {\r\n            // create KeyInfoX509Data object & include certificate subject\r\n            KeyInfoX509Data kiData = new KeyInfoX509Data(certificate);\r\n            kiData.AddSubjectName(certificate.Subject);\r\n\r\n            // create KeyInfo object with specified KeyInfoX509Data\r\n            KeyInfo keyInfo = new KeyInfo();\r\n            keyInfo.AddClause(kiData);\r\n\r\n            return keyInfo;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Gets the RSA private key from the specified signing certificate\r\n        /// </summary>\r\n        /// <param name=\"certificate\">The certificate used to extract the key from</param>\r\n        /// <returns>RSACryptoServiceProvider object</returns>\r\n        private static RSACryptoServiceProvider GetSigningRsaKeyFromCertificate(X509Certificate2 certificate)\r\n        {\r\n            RSACryptoServiceProvider key = new RSACryptoServiceProvider(new CspParameters(24));\r\n            key.FromXmlString(certificate.PrivateKey.ToXmlString(true));\r\n\r\n            return key;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Loads the specified certificate using specific storage flags for SHA-256\r\n        /// </summary>\r\n        /// <param name=\"certFile\">The certificate file to open</param>\r\n        /// <param name=\"certPassword\">The certificate password</param>\r\n        /// <param name=\"signWithSha256\">Sign the document using SHA-256</param>\r\n        /// <returns>X509Certificate2 object</returns>\r\n        private static X509Certificate2 LoadSigningCertificate(string certFile, string certPassword, bool signWithSha256)\r\n        {\r\n            X509Certificate2 certificate = null;\r\n\r\n            if (signWithSha256)\r\n            {\r\n                // register SHA-256 and open certificate with exportable private key\r\n                CryptoConfig.AddAlgorithm(typeof(RSAPKCS1SHA256SignatureDescription), RSAPKCS1SHA256SignatureDescription.SignatureMethod);\r\n                certificate = new X509Certificate2(certFile, certPassword, X509KeyStorageFlags.Exportable);\r\n            }\r\n            else\r\n            {\r\n                // open certificate with password (to be able to access the private key)\r\n                certificate = new X509Certificate2(certFile, certPassword);\r\n            }\r\n\r\n            return certificate;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Generates a SignedXml object\r\n        /// </summary>\r\n        /// <param name=\"doc\">The XML data to sign represented as XmlDocument object</param>\r\n        /// <param name=\"certificate\">The certificate used for signing represented as X509Certificate2 object</param>\r\n        /// <param name=\"signWithSha256\">Sign the document using SHA-256</param>\r\n        /// <returns></returns>\r\n        private static SignedXml GenerateSignedXml(XmlDocument doc, X509Certificate2 certificate, bool signWithSha256)\r\n        {\r\n            // create new SignedXml from XmlDocument\r\n            SignedXml signed = new SignedXml(doc);\r\n\r\n            if (signWithSha256)\r\n            {\r\n                // set signing key and signature method for SHA-256\r\n                signed.SigningKey = GetSigningRsaKeyFromCertificate(certificate);\r\n                signed.SignedInfo.SignatureMethod = RSAPKCS1SHA256SignatureDescription.SignatureMethod;\r\n            }\r\n            else\r\n            {\r\n                // set signing key and signature method for SHA-1\r\n                signed.SigningKey = certificate.PrivateKey;\r\n            }\r\n\r\n            return signed;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Signs a XML file (enveloped signature) using a digital certificate\r\n        /// </summary>\r\n        /// <param name=\"xml\">The XML data to sign represented as byte array</param>\r\n        /// <param name=\"certFile\">The certificate file to use for signing</param>\r\n        /// <param name=\"certPassword\">The certificate password</param>\r\n        /// <param name=\"signWithSha256\">Sign the document using SHA-256</param>\r\n        /// <returns>The signed data represented as byte array</returns>\r\n        private static byte[] SignEnvelopedXml(byte[] xml, string certFile, string certPassword, bool signWithSha256)\r\n        {\r\n            if (xml == null || xml.Length == 0)\r\n            {\r\n                // invalid XML array\r\n                throw new Exception(\"Nothing to sign!\");\r\n            }\r\n\r\n            // load certificate\r\n            X509Certificate2 certificate = LoadSigningCertificate(certFile, certPassword, signWithSha256);\r\n\r\n            if (!certificate.HasPrivateKey)\r\n            {\r\n                // invalid certificate\r\n                throw new Exception(\"Specified certificate not suitable for signing!\");\r\n            }\r\n\r\n            using (MemoryStream stream = new MemoryStream(xml))\r\n            {\r\n                // go to the beginning of the stream\r\n                stream.Flush();\r\n                stream.Position = 0;\r\n\r\n                // create new XmlDocument from stream\r\n                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };\r\n                doc.Load(stream);\r\n\r\n                // create new SignedXml from XmlDocument\r\n                SignedXml signed = GenerateSignedXml(doc, certificate, signWithSha256);\r\n\r\n                // create reference & add enveloped transform\r\n                Reference reference = new Reference(string.Empty);\r\n                reference.AddTransform(new XmlDsigEnvelopedSignatureTransform());\r\n\r\n                if (signWithSha256)\r\n                {\r\n                    // SHA-256 digest\r\n                    reference.DigestMethod = RSAPKCS1SHA256SignatureDescription.ReferenceDigestMethod;\r\n                }\r\n\r\n                // add reference to document\r\n                signed.AddReference(reference);\r\n\r\n                // include KeyInfo object & compute signature\r\n                signed.KeyInfo = CreateKeyInfoFromCertificate(certificate);\r\n                signed.ComputeSignature();\r\n\r\n                // get signature & append node\r\n                XmlElement xmlDigitalSignature = signed.GetXml();\r\n                doc.DocumentElement.AppendChild(doc.ImportNode(xmlDigitalSignature, true));\r\n\r\n                // returned content as byte array\r\n                return Encoding.UTF8.GetBytes(doc.OuterXml);\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Signs a XML file (enveloping signature) using a digital certificate\r\n        /// </summary>\r\n        /// <param name=\"xml\">The XML data to sign represented as byte array</param>\r\n        /// <param name=\"certFile\">The certificate file to use for signing</param>\r\n        /// <param name=\"certPassword\">The certificate password</param>\r\n        /// <param name=\"signWithSha256\">Sign the document using SHA-256</param>\r\n        /// <returns>The signed data represented as byte array</returns>\r\n        private static byte[] SignEnvelopingXml(byte[] xml, string certFile, string certPassword, bool signWithSha256)\r\n        {\r\n            if (xml == null || xml.Length == 0)\r\n            {\r\n                // invalid XML array\r\n                throw new Exception(\"Nothing to sign!\");\r\n            }\r\n\r\n            // load certificate\r\n            X509Certificate2 certificate = LoadSigningCertificate(certFile, certPassword, signWithSha256);\r\n\r\n            if (!certificate.HasPrivateKey)\r\n            {\r\n                // invalid certificate\r\n                throw new Exception(\"Specified certificate not suitable for signing!\");\r\n            }\r\n\r\n            using (MemoryStream stream = new MemoryStream(xml))\r\n            {\r\n                // go to the beginning of the stream\r\n                stream.Flush();\r\n                stream.Position = 0;\r\n\r\n                // create new XmlDocument from stream\r\n                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };\r\n                doc.Load(stream);\r\n\r\n                // craete transform (for canonicalization method & reference)\r\n                XmlDsigExcC14NTransform transform = new XmlDsigExcC14NTransform();\r\n\r\n                // create new SignedXml from XmlDocument\r\n                SignedXml signed = GenerateSignedXml(doc, certificate, signWithSha256);\r\n                signed.SignedInfo.CanonicalizationMethod = transform.Algorithm;\r\n\r\n                // get nodes (use XPath to include FATCA declaration)\r\n                XmlNodeList nodes = doc.DocumentElement.SelectNodes(\"/*\");\r\n\r\n                // define data object\r\n                DataObject dataObject = new DataObject() { Data = nodes, Id = \"FATCA\" };\r\n\r\n                // add the data we are signing as a sub-element (object) of the signature element\r\n                signed.AddObject(dataObject);\r\n\r\n                // create reference\r\n                Reference reference = new Reference(string.Format(\"#{0}\", dataObject.Id));\r\n                reference.AddTransform(transform);\r\n\r\n                if (signWithSha256)\r\n                {\r\n                    // SHA-256 digest\r\n                    reference.DigestMethod = RSAPKCS1SHA256SignatureDescription.ReferenceDigestMethod;\r\n                }\r\n\r\n                // add reference to document\r\n                signed.AddReference(reference);\r\n\r\n                // include KeyInfo object & compute signature\r\n                signed.KeyInfo = CreateKeyInfoFromCertificate(certificate);\r\n                signed.ComputeSignature();\r\n\r\n                // get signature\r\n                XmlElement xmlDigitalSignature = signed.GetXml();\r\n\r\n                // XML declaration\r\n                string xmlDeclaration = string.Empty;\r\n\r\n                if (doc.FirstChild is XmlDeclaration)\r\n                {\r\n                    // include declaration\r\n                    xmlDeclaration = doc.FirstChild.OuterXml;\r\n                }\r\n\r\n                // return signature as byte array\r\n                return Encoding.UTF8.GetBytes(string.Concat(xmlDeclaration, xmlDigitalSignature.OuterXml));\r\n            }\r\n        }\r\n        #endregion Private methods\r\n\r\n        /// <summary>\r\n        /// Signs a XML file using a digital certificate\r\n        /// </summary>\r\n        /// <param name=\"signatureType\">The type of signature to perform</param>\r\n        /// <param name=\"xml\">The XML data to sign represented as byte array</param>\r\n        /// <param name=\"certFile\">The certificate file to use for signing</param>\r\n        /// <param name=\"certPassword\">The certificate password</param>\r\n        /// <param name=\"signWithSha256\">Sign the document using SHA-256</param>\r\n        /// <returns>The signed data represented as byte array</returns>\r\n        public static byte[] Sign(XmlSignatureType signatureType, byte[] xml, string certFile, string certPassword, bool signWithSha256 = true)\r\n        {\r\n            switch (signatureType)\r\n            {\r\n\r\n                case XmlSignatureType.Enveloping:\r\n                    return SignEnvelopingXml(xml, certFile, certPassword, signWithSha256);\r\n\r\n                default:\r\n                    throw new Exception(\"Please use a valid XML signature type!\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Verifies if the signature of the file is valid\r\n        /// </summary>\r\n        /// <param name=\"signedXml\">The path to the signed file</param>\r\n        /// <returns>True or false</returns>\r\n        public static bool CheckSignature(string signedXml)\r\n        {\r\n            byte[] xml = File.ReadAllBytes(signedXml);\r\n\r\n            using (MemoryStream stream = new MemoryStream(xml))\r\n            {\r\n                // go to the beginning of the stream\r\n                stream.Flush();\r\n                stream.Position = 0;\r\n\r\n                // create new XmlDocument from stream\r\n                XmlDocument doc = new XmlDocument() { PreserveWhitespace = true };\r\n                doc.Load(stream);\r\n\r\n                // get signature node\r\n                XmlNodeList nodeList = doc.GetElementsByTagName(\"Signature\");\r\n\r\n                if (nodeList.Count != 1)\r\n                {\r\n                    // invalid file\r\n                    throw new Exception(\"Signature is missing or multiple signatures found!\");\r\n                }\r\n\r\n                // create SignedXml and load it with data\r\n                SignedXml signed = new SignedXml(doc);\r\n                signed.LoadXml(nodeList[0] as XmlElement);\r\n\r\n                // check\r\n                return signed.CheckSignature();\r\n            }\r\n        }\r\n    }\r\n}\r\n```  \r\n\r\n### Class File-RSAPKCS1SHA256SignatureDescription.cs  \r\n  \r\nCreate a new class named **RSAPKCS1SHA256SignatureDescription.cs**in the **Helpers** folder and add the code to the new **RSAPKCS1SHA256SignatureDescription.cs** class:   \r\n \r\n```  \r\nusing System;\r\nusing System.Security.Cryptography;\r\n\r\nnamespace WindowsFormsApplication1\r\n{\r\n    public sealed class RSAPKCS1SHA256SignatureDescription : SignatureDescription\r\n    {\r\n        public const string SignatureMethod = \"http://\" + \"www.w3.org/2001/04/xmldsig-more#rsa-sha256\";\r\n        public const string ReferenceDigestMethod = \"http://\" + \"www.w3.org/2001/04/xmlenc#sha256\";\r\n\r\n        public RSAPKCS1SHA256SignatureDescription()\r\n        {\r\n            KeyAlgorithm = typeof(RSACryptoServiceProvider).FullName;\r\n            DigestAlgorithm = typeof(SHA256Managed).FullName;\r\n            FormatterAlgorithm = typeof(RSAPKCS1SignatureFormatter).FullName;\r\n            DeformatterAlgorithm = typeof(RSAPKCS1SignatureDeformatter).FullName;\r\n        }\r\n\r\n        public override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)\r\n        {\r\n            if (key == null)\r\n            {\r\n                throw new Exception(\"Invalid key specified for RSAPKCS1SHA256SignatureDescription!\");\r\n            }\r\n\r\n            RSAPKCS1SignatureDeformatter deformatter = new RSAPKCS1SignatureDeformatter(key);\r\n            deformatter.SetHashAlgorithm(\"SHA256\");\r\n\r\n            return deformatter;\r\n        }\r\n\r\n        public override AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)\r\n        {\r\n            if (key == null)\r\n            {\r\n                throw new Exception(\"Invalid key specified for RSAPKCS1SHA256SignatureDescription!\");\r\n            }\r\n\r\n            RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter(key);\r\n            formatter.SetHashAlgorithm(\"SHA256\");\r\n\r\n            return formatter;\r\n        }\r\n    }\r\n}\r\n\r\n```  \r\n### Class File-ZipManager.cs   \r\n \r\nCreate a new class named **ZipManager.cs** in the Helpers folder and add the following code to the new **ZipManager.cs** class:\r\n\r\n```  \r\nusing System.IO;\r\nusing System.IO.Compression;\r\n\r\nnamespace WindowsFormsApplication1\r\n{\r\n    class ZipManager\r\n    {\r\n        public static void CreateArchive(string inputFileName, string outputFileName)\r\n        {\r\n            using (FileStream fs = new FileStream(outputFileName, FileMode.Create, FileAccess.Write))\r\n            {\r\n                using (ZipArchive archive = new ZipArchive(fs, ZipArchiveMode.Create))\r\n                {\r\n                    string entryName = Path.GetFileName(inputFileName);\r\n                    archive.CreateEntryFromFile(inputFileName, entryName, CompressionLevel.Optimal);\r\n                }\r\n            }\r\n        }\r\n\r\n        public static void UpdateArchive(string inputFileName, string outputFileName)\r\n        {\r\n            using (FileStream fs = new FileStream(outputFileName, FileMode.Open, FileAccess.ReadWrite))\r\n            {\r\n                using (ZipArchive archive = new ZipArchive(fs, ZipArchiveMode.Update))\r\n                {\r\n                    string entryName = Path.GetFileName(inputFileName);\r\n                    archive.CreateEntryFromFile(inputFileName, entryName, CompressionLevel.Optimal);\r\n                }\r\n            }\r\n        }\r\n\r\n        public static string ExtractArchive(string inputFileName, string outputFolder)\r\n        {\r\n            string zipFileName = Path.GetFileNameWithoutExtension(inputFileName);\r\n            string zipFolderPath = outputFolder + \"\\\\\" + zipFileName;\r\n\r\n            using (ZipArchive archive = ZipFile.Open(inputFileName, ZipArchiveMode.Update))\r\n            {\r\n\r\n                archive.ExtractToDirectory(zipFolderPath);\r\n            }\r\n\r\n            return zipFolderPath;\r\n\r\n        }\r\n\r\n        public static void ExtractArchive(string inputFileName, string outputFolder, bool noPath)\r\n        {\r\n\r\n            string zipFileName = Path.GetFileName(inputFileName);\r\n            string zipFolderPath = inputFileName.Replace(zipFileName, \"\");\r\n\r\n            using (ZipArchive archive = ZipFile.Open(inputFileName, ZipArchiveMode.Update))\r\n            {\r\n\r\n                archive.ExtractToDirectory(zipFolderPath);\r\n            }\r\n\r\n\r\n\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n```  \r\n\r\n### Class File-AesManager.cs\r\n  \r\nCreate a new class in the **Helpers** folder named **AesManager.cs** and add the following code to the new **AesManager.cs** class:  \r\n\r\n```  \r\n```\r\n\r\n  \r\n  \r\n\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out the documentation at https://help.github.com/pages or contact support@github.com and we’ll help you sort it out.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}